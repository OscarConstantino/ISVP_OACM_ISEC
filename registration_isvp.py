#!/usr/bin/env python3
#The program is meant to show a simple implementation of the Registration phase from the ISVP (Internet Secure Voting Protocol).
#During this phase it is important to generate the Voter's private and public keys and also the certificate. The key pair is exported so it can be stored in a
# security token. The certificate is created by the ceritification authority and solicitated by the registration authority.
#The messages are ciphered with the content the message signed. The message is deciphered and verified for the confirmation of the process.
#The program requires the next packages:
    #cryptography

#The cryptography package was chosen to perform the public key encryption and hashes operations. The RSA algorithm was chose to perform 
# the cipher, decipher, signing and verification process. Hashing is also performed using SHA2_256 and SHA3_256 when possible.
#Other properties from the cryptography package was used to perform serialization of public keys.
#The datetime package is used to generate the voter's certificate.
#The os package is used to generate pseudo random values for the voters PIN.
import datetime
import os
from cryptography.hazmat.primitives.asymmetric import rsa, padding # type: ignore
from cryptography.hazmat.primitives import serialization # type: ignore
from cryptography import x509 # type: ignore
from cryptography.x509.oid import NameOID # type: ignore
from cryptography.hazmat.primitives import hashes # type: ignore

class Registration():
    #Registration class used to perform the operations duing the ISVP Registration phase.
    #Variables:
        # SIGNATURE_STR -> constant bytes value that stores the value to separate the signature from the received message
        # BYTES_SEPARATOR = b'*****' -> constant bytes value that stores the line separator from the received message
        # __voter_id -> private variable to store  a string value with the voters id, this is used during certificate creation.
        # __voter_name -> private variable to store a string value with the voter's name.
        # __voter_last_name -> private variable to store a string value with the voter's last name.
        # __voter_pin -> private variable to store a bytes value with the pseudo random value genarted for the voter's pin.
        # __voter_private_key -> private variable to store the voter's private_key object generated by the RSA algorythm.
        # __voter_public_key -> private variable to store the voter's public_key object generated by the RSA algorythm.
        # __registration_authority_id -> private variable that stores a string value with the number of the registration authority creating the CSR.
        # __ca_public_key -> private variable to store the certification authority's public_key object generated by the RSA algorythm.
        # __ra_public_key -> private variable to store the registration authority's public_key object generated by the RSA algorythm.
    #Methods:
        # __recover_ca_public_key -> private method to recover the certificate authotity's public key 
        # __recover_ra_public_key -> private method to recover the registration authotity's public key 
        # __generate_voter_keys -> private method to generate the voter's private and public keys
        # genetate_keys -> public method that calls the private method and generate the keys
        # export_keys_to_security_token -> public method that makes two pem files with the created keys 
        # __sign_message -> private method that signs a given message with a private key
        # __cipher_message -> private method to encrypt a given message with a public key 
        # __decipher_mesage ->  private method to unencrypt a given message with a private key 
        # verify_cert -> public method to verify a given signature with a public key 

    SIGNATURE_STR = b'Signature: '
    BYTES_SEPARATOR = b'*****'
    __voter_id = '1'
    __voter_name = "John"
    __voter_last_name = "Doe"
    __voter_pin = b'0'
    __voter_private_key = None
    __voter_public_key = None
    __registration_authority_id = '1'
    __ca_public_key = None
    __ra_public_key = None

    def __init__(self):
        # Registration constructor method use to recover the public keys and set them in global variables.
        # Params:
            # -
        # Returns:
            # -
        # Description:
            #This method calls the methods to recover the public key and stores the value in the global function
        
        Registration.__recover_ca_public_key(self)
        Registration.__recover_ra_public_key(self)

    def __recover_ca_public_key(self):
        # __recover_ca_public_key private method use to recover the certification authority public key from a pem file and set the value in a global variable.
        # Params:
            # -
        # Returns:
            # -
        # Description:
            # It is necessary to read the file as binary to recover the key correctly. Then, use the load_pem_public_key method to asign the
            # value in a variable
        
        with open("CA_Keys/CA_Public_Key.pem", "rb") as key_file:
              Registration.__ca_public_key = serialization.load_pem_public_key(
                key_file.read()
            )
              
    def __recover_ra_public_key(self):
        # __recover_ra_public_key private method use to recover the registration authority public key from a pem file and set the value in a global variable.
        # Params:
            # -
        # Returns:
            # -
        # Description:
            # It is necessary to read the file in binary mode to recover the key correctly. Then, use the load_pem_public_key method to asign the
            # recovered key in a variable.
        
        with open("RA_Keys/RA_Public_Key.pem", "rb") as key_file:
              Registration.__ra_public_key = serialization.load_pem_public_key(
                key_file.read()
            )

    def __generate_voter_keys(self):
        # __generate_voter_keys private method use to generate the voter's private and public keys using RSA algorithym
        # Params:
            # -
        # Returns:
            # -
        # Description:
            # Using the cryptography package we set a private RSA key using a key exponent of 65537 which is the suggested number and a size of 2048 bytes.
            # The public key is generated through the private key.

        Registration.__voter_private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048,)
        Registration.__voter_public_key = Registration.__voter_private_key.public_key()

    def genetate_keys(self):
        # genetate_keys public method use to call the private method __generate_voter_keys and generate the voters keys.
        # Params:
            # -
        # Returns:
            # boolean True
        # Description:
            # The method is only used to call the private method externally.
        
        Registration.__generate_voter_keys(self)
        print("Voter keys generated ...")
        return True

    def export_keys_to_security_token(self):
        # export_keys_to_security_token public method use to export the created keys into pem files. It also generates a 
        # pseudo random PIN byte number for the file encription
        # Params:
            # -
        # Returns:
            # boolean True
        # Description:
            # The os.urandom method is used to make a more "reliable" method to generate random numbers.
            # The file is write in bytes mode and with the .pem extension.

        Registration.__voter_pin = os.urandom(2)
        print("GENERATED PIN: ",int.from_bytes(Registration.__voter_pin,byteorder="little"))
        pem_private_key = Registration.__voter_private_key.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8,encryption_algorithm=serialization.BestAvailableEncryption(Registration.__voter_pin))
        with open("Voter_Private_Key.pem", "wb") as fo:
                fo.write(pem_private_key)
        pem_public_key = Registration.__voter_public_key.public_bytes(encoding=serialization.Encoding.PEM,format=serialization.PublicFormat.SubjectPublicKeyInfo)
        with open("Voter_Public_Key.pem", "wb") as fo:
                fo.write(pem_public_key)
        print("Voter keys exported to pem files ...")
        return True

    def __sign_message(self, message, private_key):
        # __sign_message private method use to sign a message with a given private key
        # Params:
            # - bytes message
            # - obj private_key
        # Returns:
            # obj signature
        # Description:
            # The method uses the private_key object to use the sign method to sign a given message and hashing it with
            # a SHA3 algorithym.

        signature = private_key.sign(
            message,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA3_256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA3_256()
        )
        return signature
    
    def __cipher_message(self, message, public_key):
        # __cipher_message private method use to encrypt a message with a given public key
        # Params:
            # - bytes message
            # - obj public_key
        # Returns:
            # list cipher_message
        # Description:
            # The message is divided in a smaller size, since the maximum size is 2048 bytes.
            # Each part of the split message is encrypted individually, then the parts are grouped in a list.

        split_message = [message[i:i+public_key.key_size//16] for i in range(0, len(message), public_key.key_size//16)]
        cipher_message = []
        for line in split_message:
            ciphered_line = public_key.encrypt(line, padding.OAEP(
              mgf=padding.MGF1(algorithm=hashes.SHA256()),
              algorithm=hashes.SHA256(),
              label=None
              )
            )
            cipher_message.append(ciphered_line)
        return cipher_message
    
    def __decipher_mesage(self, ciphered_message, private_key):
        # __decipher_mesage private method use to dencrypt a message with a given private key
        # Params:
            # - bytes ciphered_message
            # - obj private_key
        # Returns:
            # list decipher_message
        # Description:
            # The message recovered from the file is splited by the separator so it can be decrypted correctly.
            # The same separator must be used to recover the original message and the last element is not included
            # since it is an empty element, finally the parts are grouped in a list.
            # Due to some possible problems during the decipher process, it is re-tried ten times until an error is raised.

        for _ in range(0,10):
            try:
                recovered_csr_total = b''.join(ciphered_message).split(Registration.BYTES_SEPARATOR)[:-1]
                decipher_message = []
                for line in recovered_csr_total:
                    deciphered_line = private_key.decrypt(
                        line,
                        padding.OAEP(
                            mgf=padding.MGF1(algorithm=hashes.SHA256()),
                            algorithm=hashes.SHA256(),
                            label=None
                        )
                    )
                    decipher_message.append(deciphered_line)
                return decipher_message
            except Exception:
                continue
        print("There was an error during the decryption")

    def verify_cert(self, signature, message, public_key):
        # verify_cert public method use to verify a signature with a given public key
        # Params:
            # - bytes signature
            # - bytes message
            # - obj public_key
        # Returns:
            # boolean True | False
        # Description:
            # The signature is verified using the original message and the public key. A SHA3_256 is used for the 
            # verification process which is the same used in the signing process.
            # If the verification is correct it should return True, if not it will return False.

        try:
            public_key.verify(
                signature,
                message,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA3_256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA3_256()
            )
            return True
        except Exception as e:
            print(e)
            return False

class RegistrationCA(Registration):
    #RegistrationCA class used to perform the operations from the Certification Authority duing the ISVP Registration phase.
    #Variables:
       # __ca_private_key -> private variable to store the certifcation authority's private_key object generated by the RSA algorythm.
    #Methods:
        # __recover_ca_private_key -> private method to recover the certificate authotity's private key 
        # __generate_voter_certificate -> private method to recover the registration authotity's public key
        # send_data_to_ra -> private method to recover the registration authotity's public key
        # recieve_data_from_ra -> private method to recover the registration authotity's public key

    __ca_private_key = None

    def __init__(self):
        # RegistrationCA constructor method use to recover the private key and set them in a global variable.
        # Params:
            # -
        # Returns:
            # -
        # Description:
            #This method calls the method to recover the certification authority private key and stores the value in the global function

        RegistrationCA.__recover_ca_private_key(self)

    def __recover_ca_private_key(self):
        # __recover_ca_private_key private method use to recover the certification authority private key from a pem file and set the value in a global variable.
        # Params:
            # -
        # Returns:
            # -
        # Description:
            # It is necessary to read the file as binary to recover the key correctly. Then, use the load_pem_public_key method to asign the
            # value in a variable

         with open("CA_Keys/CA_Private_Key.pem", "rb") as key_file:
              RegistrationCA.__ca_private_key = serialization.load_pem_private_key(
                key_file.read(),
                password=b'1234',
            )
              
    def __generate_voter_certificate(self):
        # __generate_voter_certificate private method use to generate a certificate with the voter's data
        # Params:
            # - 
        # Returns:
            # obj voter_cert
        # Description:
            # The certification is made with the certificate authority's public key and signed with the private key.
            # After it is created, it is exported in a .pem file.

        subject = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CA"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "Alberta"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "Calgary"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "MISP Group 4"),
            x509.NameAttribute(NameOID.COMMON_NAME, Registration._Registration__voter_name),
            x509.NameAttribute(NameOID.GIVEN_NAME, Registration._Registration__voter_last_name),
            x509.NameAttribute(NameOID.USER_ID, Registration._Registration__voter_id),
            x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, Registration._Registration__registration_authority_id),
        ])
        issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CA"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "Alberta"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "Calgary"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, 'CHOSEN CERIFICATION AUTHORITY'),
            x509.NameAttribute(NameOID.COMMON_NAME, 'companysite.com'),
            x509.NameAttribute(NameOID.ORGANIZATION_IDENTIFIER, Registration._Registration__registration_authority_id),
        ])
        voter_cert = x509.CertificateBuilder().subject_name(subject).issuer_name(issuer).public_key(
            Registration._Registration__ca_public_key
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.datetime.now(datetime.timezone.utc)
        ).not_valid_after(
            # Our certificate will be valid for 10 days
            datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=10)
        ).add_extension(
            x509.SubjectAlternativeName([x509.DNSName("localhost")]),
        critical=False,
        # Sign our certificate with our private key
        ).sign(RegistrationCA.__ca_private_key, hashes.SHA3_256())
        with open("CA_Keys/Voter_Certificate.pem", "wb") as f:
            f.write(voter_cert.public_bytes(serialization.Encoding.PEM))
        
        return voter_cert

    def send_data_to_ra(self):
        # send_data_to_ra public method use to send the created certificate with the voter's data, the data is ciphered 
        # before sent with the certificate signature.
        # Params:
            # - 
        # Returns:
            # boolean True
        # Description:
            # The file is also writen in byte format and it is separated with the constant value.

        certificate = RegistrationCA.__generate_voter_certificate(self)
        print("Voter certificate generated correctly...")
        signature = Registration._Registration__sign_message(self,certificate.public_bytes(serialization.Encoding.PEM),RegistrationCA.__ca_private_key)
        print("Voter certificate signed by certification authority correctly...")
        print("The certificate was ciphered correctly")
        message = certificate.public_bytes(serialization.Encoding.PEM) + Registration.SIGNATURE_STR + signature
        ciphered_message = Registration._Registration__cipher_message(self,message,Registration._Registration__ra_public_key)
        with open("Cipher_Voter_CERT.txt", "wb") as cert_file:
            for line in ciphered_message:
                cert_file.write(line+Registration.BYTES_SEPARATOR)
        print("File content created correctly ...")
        return True

    def recieve_data_from_ra(self):
        # recieve_data_from_ra public method use to recieve the csr from the registration authority with the voter's data.
        # Params:
            # - 
        # Returns:
            # boolean True
        # Description:
            # The function recieve the ciphered information and it is deciphered for the later operations.
            # The recovered data is separated by the signature and the CSR data.
            # The signature is verified using the registration authority's public key.

        with open("Cipher_CSR.txt", "rb") as ciphered_csr_file:
            recovered_csr = ciphered_csr_file.readlines()
        recovered_data = Registration._Registration__decipher_mesage(self,recovered_csr,RegistrationCA.__ca_private_key)
        formated_data = b''.join(recovered_data).split(b'ID_RA: ')
        signature = formated_data[1].split(Registration.SIGNATURE_STR)[1]
        csr = formated_data[0]
        if Registration.verify_cert(self, signature, csr, Registration._Registration__ra_public_key):
            print("The signature was verified correctly.")
        else:
            print("The signature verification failed.")
        return True

class RegistrationRA(Registration):
    #RegistrationRA class used to perform the operations duing the ISVP Registration phase.
    #Variables:
       # __ra_private_key ->  private variable to store the registration authority's private_key object generated by the RSA algorythm.
       # __voter_csr -> private variable to store the generated voter's csr file.
    #Methods:
        # __recover_ra_private_key -> private method to recover the registration authotity's private key 
        # send_data_to_ca -> public method to send the csr file to the certification authority
        # recieve_data_from_ca -> public method to recieve the voter's certificate from the certification authority
        # __generate_voter_csr -> private method to generate the voter's csr
        # export_voter_csr -> public method to export the csr to a pem file

    __ra_private_key = None
    __voter_csr = None

    def __init__(self):
        # RegistrationRA constructor method use to recover the private key and set them in a global variable.
        # Params:
            # -
        # Returns:
            # -
        # Description:
            #This method calls the method to recover the registration authority private key and stores the value in the global function

        RegistrationRA.__recover_ra_private_key(self)

    def __recover_ra_private_key(self):
        # __recover_ra_private_key private method use to recover the registration authority private key from a pem file and set the value in a global variable.
        # Params:
            # -
        # Returns:
            # -
        # Description:
            # It is necessary to read the file as binary to recover the key correctly. Then, use the load_pem_public_key method to asign the
            # value in a variable 
        
         with open("RA_Keys/RA_Private_Key.pem", "rb") as key_file:
              RegistrationRA.__ra_private_key = serialization.load_pem_private_key(
                key_file.read(),
                password=b'1234',
            )    

    def send_data_to_ca(self):
        # send_data_to_ca public method use to send the created csr with the voter's data, the data is ciphered 
        # before sent with the csr signature.
        # Params:
            # - 
        # Returns:
            # boolean True
        # Description:
            # The file is also writen in byte format and it is separated with the constant value.

        csr = RegistrationRA.__voter_csr.public_bytes(serialization.Encoding.PEM)
        id_ra = Registration._Registration__registration_authority_id
        signature = Registration._Registration__sign_message(self, RegistrationRA.__voter_csr.public_bytes(serialization.Encoding.PEM),RegistrationRA.__ra_private_key)
        crst_id_ra_sig = csr + bytes("ID_RA: " + id_ra, 'ascii') + Registration.SIGNATURE_STR + signature
        print("Certificate ciphered with the ID_RA and certificate signature ...")
        with open("Cipher_CSR.txt", "wb") as csr_file:
            for line in Registration._Registration__cipher_message(self,crst_id_ra_sig,Registration._Registration__ca_public_key):
                csr_file.write(line+Registration.BYTES_SEPARATOR)
        print("File content created correctly ...")
        return True
    
    def recieve_data_from_ca(self):
        # recieve_data_from_ca public method use to recieve the certificate from the certification authority with the voter's data.
        # Params:
            # - 
        # Returns:
            # -
        # Description:
            # The function recieve the ciphered information and it is deciphered for the later operations.
            # The recovered data is separated by the signature and the certificate data.
            # The signature is verified using the registration authority's public key.

        with open("Cipher_Voter_CERT.txt", "rb") as ciphered_csr_file:
            recovered_csr = ciphered_csr_file.readlines()
        recovered_data = Registration._Registration__decipher_mesage(self,recovered_csr,RegistrationRA.__ra_private_key)
        formated_data = b''.join(recovered_data).split(Registration.SIGNATURE_STR)
        if Registration.verify_cert(self, formated_data[1], formated_data[0], Registration._Registration__ca_public_key):
            print("The voter's certification signature was verified correctly.")
        else:
            print("The signature verification failed.")
        return True

    def __generate_voter_csr(self):
        # __generate_voter_csr private method use to generate a csr with the voter's data
        # Params:
            # - 
        # Returns:
            # obj voter_cert
        # Description:
            # The csr is signed with the certificate registration authority private key.
        
        RegistrationRA.__voter_csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([
            # Provide various details about who we are.
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CA"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "Alberta"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "Calgary"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "MISP Group 4"),
            x509.NameAttribute(NameOID.COMMON_NAME, Registration._Registration__voter_name),
            x509.NameAttribute(NameOID.GIVEN_NAME, Registration._Registration__voter_last_name),
            x509.NameAttribute(NameOID.USER_ID, Registration._Registration__voter_id),
            x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, Registration._Registration__registration_authority_id),
        ])).add_extension(
            x509.SubjectAlternativeName([
            # Describe what sites we want this certificate for.
            x509.DNSName("misp.group.4.com"),
            x509.DNSName("www.misp.group.4.com")
        ]),
            critical=False,
            # Sign the CSR with our private key.
        ).sign(RegistrationRA.__ra_private_key, hashes.SHA3_256())
    
    def export_voter_csr(self):
        # export_voter_csr public method use to export the csr object to a .pem file.
        # Params:
            # - 
        # Returns:
            # boolean True
        # Description:
            # The file is write in bytes format 

        RegistrationRA.__generate_voter_csr(self)
        print("Voter CSR generated ...")
        # Write our CSR out to disk.
        with open("Voter_CSR.pem", "wb") as f:
            f.write(RegistrationRA.__voter_csr.public_bytes(serialization.Encoding.PEM))
        print("Voter CSR has been exported to be sent to the CA ...")
        return True