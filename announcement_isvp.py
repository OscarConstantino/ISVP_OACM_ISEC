#!/usr/bin/env python3
#The program is meant to show a simple implementation of the Authentication phase from the ISVP (Internet Secure Voting Protocol).
#During this phase it is important to generate the key pairs for the Electoral Authority. This key pair is used in next phases so it is 
# necessary to generate them correctly.
#The private key must be shared using a secret sharing function, which splits the key in different parts.
#The public key is signed for the verification processed. Also, it is possible to verify if the given signature matches with the created private key.
#Finally, the public data is "published" in the bulletin board.
#The program requires the next packages:
    #cryptography
    #sslib

#The cryptography package was chosen to perform the public key encryption and hashes operations. The elliptic curves algorithm was chose to perform 
# the sign and verification process.
#Other properties from the cryptography package was used to perform serialization of public keys and to decode the electronic signature.
#The sslib package was used to perform the Shamir secret sharing function and split the private key and also for reconstruction.

from cryptography.hazmat.primitives import hashes # type: ignore
from cryptography.hazmat.primitives.asymmetric import ec # type: ignore
from cryptography.hazmat.primitives.serialization import PublicFormat, PrivateFormat, Encoding, NoEncryption # type: ignore
from cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature # type: ignore
from sslib import shamir # type: ignore

class Announcement():
    #Announcement class used to perform the necessary operations duing the Announcement phase in the ISVP
    #Variables:
        # __election_type -> private variable to store a string value of the election type
        # __election_opening_datetime -> private variable to store a string value of the date and time of the opening event
        # __election_closing_datetime -> private variable to store a string value of the date and time of the clsoing event
        # __ea_private_key -> private variable to store a private_key object generated by the elliptic curve algorythm.
        # __ea_public_key -> private variable to store a public_key object generated by the elliptic curve algorythm.
        # __signed_public_key -> private variable to store an object with the resulting signature of the public key.
        # required_shares -> public variable that stores an integer with the number of required shares to recover the secret shared.
        # distributed_shares -> public variable that stores an integer with the number of shares.
    #Methods:
        # __set_election_data -> private method used to set the __election_type, __election_opening_datetime and __election_closing_datetime variables.
        # ask_election_data -> public method used to call the private method __set_election_data.
        # __generate_electoral_authority_keys -> private method used to generate the private and public keys for the electoral_authority entity
        # __share_private_key -> private method use to perform the secret share function of the privary key
        # __recover_private_key -> private method use for the reconstruction of the private key.
        # __sign_ea_public_key -> private method use to generate the signed public key
        # verify_signature_ea_public_key -> public method use to verify a given signature with the electoral_authority public key
        # publish_data_bulletin_board -> public method use to store the generated data into a file
        # announcement_process -> public method use to perform multple operations from the class

    __election_type = 'TEST'
    __election_opening_datetime = '1970-01-01 00:00:00'
    __election_closing_datetime = '1970-01-01 23:59:59'
    __ea_private_key = None
    __ea_public_key = None
    __signed_public_key = None
    required_shares = 2
    distributed_shares = 5

    def __set_election_data(self):
        # __set_election_data method use to set the Announcement class variables.
        # Params:
            # -
        # Description:
            #This is a simple example of how the parameters can be recovered. This can be performed differently, more complex like a web interface.
            #It is expected to recieve a string with the type and the timestamps with the given format.
            #If there is an error during the data setting an Exception will be raise.

        try:
            Announcement.__election_type = input("Indicate the election type: ")
            Announcement.__election_opening_datetime = input('Enter the opening date and hour in the next format YYYY-MM-DD HH:MM:SS, like in the next example (2019-11-04 14:53:00): ')
            Announcement.__election_closing_datetime = input('Enter the opening date and hour in the next format YYYY-MM-DD HH:MM:SS, like in the next example (2019-11-04 14:53:00): ')
        except Exception as e:
            print(repr(e))

    def ask_election_data(self):
        # ask_election_data method use to access the private method __set_election_data and set the values.
        # Paramas:
            # -
        # Description:
            # -
        Announcement.__set_election_data(self)

    def __generate_electoral_authority_keys(self):
        # __generate_electoral_authority_keys method that generates the Electoral Authority private and public keys.
        # Params:
            # -
        # Return:
            # Boolean True
        # Description:
            # The algorythm use is the elliptic curve secp384r1 using a 384-bit key size.
            # The public key is generated from the private key.
            # Both values are stored in the class variables __ea_private_key and __ea_public_key.

        Announcement.__ea_private_key = ec.generate_private_key(ec.SECP384R1())  # Generate a private key using the elliptic curve secp384r1
        Announcement.__ea_public_key = Announcement.__ea_private_key.public_key() # Generate a public key using the elliptic curve secp384r1
        return True
    
    def __share_private_key(self):
        # __generate_electoral_authority_keys method to apply the secret sharing function to the private key.
        # Params:
            # -
        # Return:
            # Boolean True
        # Description:
            # The algorythm use is for the secret sharing is the SSS (Shamir secret sharing).
            # Since the __ea_private_key is an object, it is necessary to encode the private key to the tradittionalOpenSSL and then split 
            # the key in the number of specified shares options.
            # The resulting shares are stored in different files. In this phase, these files are stored in a Security Token with a PIN to access the file.

        private_key_raw = str(Announcement.__ea_private_key.private_bytes(Encoding.PEM, PrivateFormat.TraditionalOpenSSL, encryption_algorithm=NoEncryption()))
        data = shamir.to_base64(shamir.split_secret(private_key_raw.encode('ascii'), Announcement.required_shares, Announcement.distributed_shares))
        share_portion = 1
        for share in data["shares"]:
            with open("Share_key_portion #"+str(share_portion)+".txt", "wt") as fo:
                fo.write(str(data["required_shares"])+"\n")
                fo.write(str(data["prime_mod"])+"\n")
                fo.write(str(share))
            share_portion+=1
        return True

    def __recover_private_key(self):
        # __recover_private_key method to recover the secret shared by the private key.
        # Params:
            # -
        # Return:
            # Boolean True
        # Description:
            # To recover the key, it is necessary to reconstruct the shares from the files. In this case, the file names are numbered so it is 
            # easier to read them and recover the data. But the method can be more complex depending on the method use to store the shares.
            # The idea is to reconstruct the original "data" structure using the parameters stored in the file.
                # The data variable is a dictionary with the next params:
                    # prime_mod -> a string value with the prime module used for the reconstruction process.
                    # required_shares -> an integer value with the minimum number of shares to reconstruct the original data.
                    # shares -> a list with the different shares for the secret reconstruction.
            # The range of the reconstruction is based on the required_shares value. This also proves that it is not necessary to have all 
            # shares, but it will depend on the parameters set.
            # The shares are recovered from each file and saved in a local variable.
            # The recovered data is used in the recovering process.
            # Finally the key is partially shown and a hashed is calculatedjust to print it and make the verification. This is not necessary, 
            # it is just for testing purpouses.

        data = {}
        data["prime_mod"] = ''
        data["required_shares"] = ''
        shares = []
        for share_portion in range(Announcement.required_shares):
            lncnt = 1
            for line in open("Share_key_portion #"+str(share_portion+1)+".txt", 'rt'):
                if lncnt == 1 and share_portion == 0:
                    data["required_shares"] = int(line.rstrip('\n'))
                if lncnt == 2 and share_portion == 0:
                    data["prime_mod"] = line.rstrip('\n')
                if lncnt > 2:
                    shares.append(line.rstrip('\n'))
                lncnt+=1
        data["shares"] = shares
        recovered_private_key = shamir.recover_secret(shamir.from_base64(data)).decode('ascii')
        digest = hashes.Hash(hashes.SHA3_256())
        digest.update(str.encode(recovered_private_key))
        recovered_key_hash = digest.finalize()
        print("RECOVERED PRIVATE KEY PARSED: ", recovered_private_key[:40])
        print("RECOVERED PRIVATE KEY HASH BYTES: ",recovered_key_hash) #Printing the hash of the private key just for testing purpouse
        return True

    def __sign_ea_public_key(self):
        # __sign_ea_public_key method to sign the Electoral Authority public key
        # Params:
            # -
        # Return:
            # Boolean True
        # Description:
            # The signing process is performed by the private key. In this case, the public key is in a SubjectPublicKeyInfo format. The signing use a 
            # SHA3_256 hash algorythm. It is important to set the same hash for both signing and verification.

        Announcement.__signed_public_key = Announcement.__ea_private_key.sign(Announcement.__ea_public_key.public_bytes(Encoding.PEM, PublicFormat.SubjectPublicKeyInfo),ec.ECDSA(hashes.SHA3_256()))
        return True

    def verify_signature_ea_public_key(self, signature):
        # verify_signature_ea_public_key method to sign the Electoral Authority public key
        # Params:
            # signature -> an object with the generated public key signature.
        # Return:
            # Boolean True
        # Description:
            # The verification process is performed by the public key. In this case, the given signature is compared with the original data and using 
            # the same hash algorythm, SHA3_256.
            # If the signature is valid a message showing the success will be prompt. If not, an error message will be prompt.
        
        try:
            Announcement.__ea_public_key.verify(signature, Announcement.__ea_public_key.public_bytes(Encoding.PEM, PublicFormat.SubjectPublicKeyInfo), ec.ECDSA(hashes.SHA3_256()))
            print("The given signed key is valid")
            print("The signature encoded in ASN.1 sequence is: ", decode_dss_signature(signature))
            return True
        except Exception:
            print("ERROR: The given signed key is not valid.")

    def publish_data_bulletin_board(self):
        # publish_data_bulletin_board method to export the generated data in the "bulletin board"
        # Params:
            # -
        # Return:
            # Boolean True
        # Description:
            # The recovered data is export into a file called "Bulletin_board.txt".
        
        try:
            with open("Bulletin_board.txt", "wt") as fo:
                fo.write("Type: "+Announcement.__election_type+"\n")
                fo.write("Opening datetime: "+Announcement.__election_opening_datetime+"\n")
                fo.write("Closing datetime: "+Announcement.__election_closing_datetime+"\n")
                fo.write("Public Key: "+str(Announcement.__ea_public_key.public_bytes(Encoding.PEM, PublicFormat.SubjectPublicKeyInfo))+"\n")
                fo.write("Signed Public Key ASN.1 sequence: "+str(decode_dss_signature((Announcement.__signed_public_key))))                
            return True
        except Exception as e:
            print("There was an error getting the data: ",e)

    def announcement_process(self):
        # announcement_process method to test the methods from the Announcement class
        # Params:
            # -
        # Return:
            # Boolean True
        # Description:
            # The class methods are tested in the correct order to perform the process, except the setting of the class variables. Since they are inputs from
            # the command terminal, ommiting the step makes the process much faster.
        
        Announcement.__generate_electoral_authority_keys(self)
        Announcement.__share_private_key(self)
        Announcement.__recover_private_key(self)
        Announcement.__sign_ea_public_key(self)
        Announcement.verify_signature_ea_public_key(self,Announcement.__signed_public_key)
        Announcement.publish_data_bulletin_board(self)
        return True